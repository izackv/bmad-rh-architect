meta:
  template_id: rh-pipeline-template
  name: "CI/CD Pipeline Template â€“ Red Hat Platforms"
  version: 0.1.0
  owner_role: "Red Hat DevOps Engineer"
  audience:
    - DevOps Engineers
    - Platform Engineers
    - Developers

structure:
  description: |
    Templates for CI/CD pipelines on various platforms targeting
    Red Hat environments.

sections:
  - id: tekton-pipeline
    title: "Tekton Pipeline"
    prompt: |
      Create Tekton Pipeline for OpenShift Pipelines:

    template: |
      ---
      apiVersion: tekton.dev/v1beta1
      kind: Pipeline
      metadata:
        name: ${PIPELINE_NAME}
        namespace: ${NAMESPACE}
      spec:
        description: ${DESCRIPTION}

        params:
          - name: git-url
            type: string
            description: Git repository URL
          - name: git-revision
            type: string
            description: Git revision
            default: main
          - name: image-name
            type: string
            description: Target image name
          - name: image-tag
            type: string
            description: Image tag
            default: latest

        workspaces:
          - name: shared-workspace
          - name: git-credentials
          - name: image-registry-credentials

        tasks:
          - name: clone
            taskRef:
              name: git-clone
              kind: ClusterTask
            params:
              - name: url
                value: $(params.git-url)
              - name: revision
                value: $(params.git-revision)
            workspaces:
              - name: output
                workspace: shared-workspace
              - name: basic-auth
                workspace: git-credentials

          - name: build
            taskRef:
              name: ${BUILD_TASK}
            runAfter:
              - clone
            workspaces:
              - name: source
                workspace: shared-workspace

          - name: test
            taskRef:
              name: ${TEST_TASK}
            runAfter:
              - build
            workspaces:
              - name: source
                workspace: shared-workspace

          - name: build-image
            taskRef:
              name: buildah
              kind: ClusterTask
            runAfter:
              - test
            params:
              - name: IMAGE
                value: $(params.image-name):$(params.image-tag)
            workspaces:
              - name: source
                workspace: shared-workspace
              - name: dockerconfig
                workspace: image-registry-credentials

          - name: deploy
            taskRef:
              name: openshift-client
              kind: ClusterTask
            runAfter:
              - build-image
            params:
              - name: SCRIPT
                value: |
                  oc set image deployment/${APP_NAME} \
                    ${CONTAINER_NAME}=$(params.image-name):$(params.image-tag) \
                    -n ${TARGET_NAMESPACE}
                  oc rollout status deployment/${APP_NAME} \
                    -n ${TARGET_NAMESPACE} --timeout=300s

  - id: tekton-trigger
    title: "Tekton Trigger"
    prompt: |
      Create Tekton Trigger for webhook integration:

    template: |
      ---
      apiVersion: triggers.tekton.dev/v1beta1
      kind: TriggerTemplate
      metadata:
        name: ${PIPELINE_NAME}-template
        namespace: ${NAMESPACE}
      spec:
        params:
          - name: git-revision
          - name: git-url
        resourcetemplates:
          - apiVersion: tekton.dev/v1beta1
            kind: PipelineRun
            metadata:
              generateName: ${PIPELINE_NAME}-run-
            spec:
              pipelineRef:
                name: ${PIPELINE_NAME}
              params:
                - name: git-url
                  value: $(tt.params.git-url)
                - name: git-revision
                  value: $(tt.params.git-revision)
              workspaces:
                - name: shared-workspace
                  persistentVolumeClaim:
                    claimName: pipeline-workspace-pvc
      ---
      apiVersion: triggers.tekton.dev/v1beta1
      kind: TriggerBinding
      metadata:
        name: ${PIPELINE_NAME}-binding
        namespace: ${NAMESPACE}
      spec:
        params:
          - name: git-revision
            value: $(body.head_commit.id)
          - name: git-url
            value: $(body.repository.clone_url)
      ---
      apiVersion: triggers.tekton.dev/v1beta1
      kind: EventListener
      metadata:
        name: ${PIPELINE_NAME}-listener
        namespace: ${NAMESPACE}
      spec:
        serviceAccountName: pipeline
        triggers:
          - name: github-push
            bindings:
              - ref: ${PIPELINE_NAME}-binding
            template:
              ref: ${PIPELINE_NAME}-template

  - id: jenkins-pipeline
    title: "Jenkins Pipeline"
    prompt: |
      Create Jenkinsfile for Jenkins Pipeline:

    template: |
      // Jenkinsfile
      pipeline {
          agent {
              kubernetes {
                  yaml '''
                      apiVersion: v1
                      kind: Pod
                      spec:
                        containers:
                        - name: builder
                          image: ${BUILD_IMAGE}
                          command: [cat]
                          tty: true
                        - name: buildah
                          image: quay.io/buildah/stable
                          command: [cat]
                          tty: true
                          securityContext:
                            privileged: true
                  '''
              }
          }

          environment {
              IMAGE_REGISTRY = '${IMAGE_REGISTRY}'
              IMAGE_NAME = '${IMAGE_NAME}'
              REGISTRY_CREDS = credentials('registry-credentials')
          }

          parameters {
              string(name: 'GIT_BRANCH', defaultValue: 'main')
              string(name: 'IMAGE_TAG', defaultValue: 'latest')
          }

          stages {
              stage('Checkout') {
                  steps {
                      git branch: params.GIT_BRANCH,
                          credentialsId: 'git-credentials',
                          url: '${GIT_URL}'
                  }
              }

              stage('Build') {
                  steps {
                      container('builder') {
                          sh '${BUILD_COMMAND}'
                      }
                  }
              }

              stage('Test') {
                  steps {
                      container('builder') {
                          sh '${TEST_COMMAND}'
                      }
                  }
                  post {
                      always {
                          junit '${TEST_RESULTS}'
                      }
                  }
              }

              stage('Build Image') {
                  steps {
                      container('buildah') {
                          sh """
                              buildah bud -t ${IMAGE_REGISTRY}/${IMAGE_NAME}:${params.IMAGE_TAG} .
                              buildah push --creds ${REGISTRY_CREDS_USR}:${REGISTRY_CREDS_PSW} \
                                  ${IMAGE_REGISTRY}/${IMAGE_NAME}:${params.IMAGE_TAG}
                          """
                      }
                  }
              }

              stage('Deploy') {
                  steps {
                      sh """
                          oc set image deployment/${APP_NAME} \
                              ${CONTAINER_NAME}=${IMAGE_REGISTRY}/${IMAGE_NAME}:${params.IMAGE_TAG} \
                              -n ${TARGET_NAMESPACE}
                          oc rollout status deployment/${APP_NAME} -n ${TARGET_NAMESPACE}
                      """
                  }
              }
          }

          post {
              success { echo 'Pipeline succeeded!' }
              failure { echo 'Pipeline failed!' }
          }
      }

  - id: github-actions
    title: "GitHub Actions"
    prompt: |
      Create GitHub Actions workflow:

    template: |
      name: CI/CD

      on:
        push:
          branches: [main]
        pull_request:
          branches: [main]

      env:
        IMAGE_REGISTRY: ${IMAGE_REGISTRY}
        IMAGE_NAME: ${{ github.repository }}

      jobs:
        build-test:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4

            - name: Set up build environment
              uses: ${SETUP_ACTION}

            - name: Build
              run: ${BUILD_COMMAND}

            - name: Test
              run: ${TEST_COMMAND}

        build-push-image:
          needs: build-test
          runs-on: ubuntu-latest
          if: github.event_name == 'push'
          steps:
            - uses: actions/checkout@v4

            - name: Log in to registry
              uses: docker/login-action@v3
              with:
                registry: ${{ env.IMAGE_REGISTRY }}
                username: ${{ github.actor }}
                password: ${{ secrets.REGISTRY_TOKEN }}

            - name: Build and push
              uses: docker/build-push-action@v5
              with:
                push: true
                tags: |
                  ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
                  ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:latest

        deploy:
          needs: build-push-image
          runs-on: ubuntu-latest
          environment: ${TARGET_ENV}
          steps:
            - uses: redhat-actions/oc-login@v1
              with:
                openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}
                openshift_token: ${{ secrets.OPENSHIFT_TOKEN }}

            - name: Deploy
              run: |
                oc set image deployment/${APP_NAME} \
                  ${CONTAINER_NAME}=${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
                  -n ${TARGET_NAMESPACE}
                oc rollout status deployment/${APP_NAME} -n ${TARGET_NAMESPACE}

best_practices:
  - Separate build, test, and deploy stages
  - Use workspace/artifacts for sharing between stages
  - Implement proper secret management
  - Include test reporting
  - Add rollback capabilities
  - Use environment-specific deployments
  - Implement approval gates for production
  - Cache dependencies when possible
